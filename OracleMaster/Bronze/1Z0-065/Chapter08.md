# 第八章 スキーマオブジェクトの管理

## 8.1 スキーマオブジェクトの概要と表の管理

**スキーマとスキーマオブジェクト　★★★★**

- ユーザーアカウントを作成すると、ユーザーの「`スキーマ`」も同時に、かつ**同じ名前**で作成される。

- `スキーマ`は、データベースオブジェクトの集合であり、オブジェクトを管理する際に枠組み。

- `スキーマ`に属するオブジェクトを`スキーマオブジェクト`という。

- `スキーマ`はユーザーによって所有される。

- `スキーマ名`はユーザー名と同じ名前である。

- データベース作成時に自動的に作成される`スキーマ`に「**SYS**」と「**SYSTEM**」がある。

|スキーマ名 |説明 |
|---- |---- |
|SYS |**データディクショナリを構成するすべての実表およびビュー**が作成されるスキーマ。 |
|SYSTEM |**管理情報を格納するための追加の表やビュー、およびOracle製品のオプションやツールで使用される内部的な表やビュー**が作成されるスキーマ。 |

- `事前構成済みデータベース`を作成した場合は`サンプルスキーマ`を作成することも可能です。

- 自分が所有している`スキーマオブジェクト`以外の`スキーマオブジェクト`にアクセスするには、ユーザに`オブジェクト権限`が付与されている必要がある。

- オブジェクト名を付ける場合は次の命名規則に従う。

  + 長さは３０バイト以下(文字数ではなく、バイト数)

  + 先頭の文字は数字以外の文字(数字および記号不可)

  + 使用できる文字は、英数字および漢字、カタカナ、ひらかな

  + 使用できる記号は「_」、「$」、「#」３種類のみ。

  + 同一のスキーマ内で重複する名前は指定できない。

  + OracleのSQLにおける`予約語`は使用できない。

  + アルファバイトの大文字・小文字は**区別されない**。

**表の作成　★★★★**

- `表`はデータベースにおける**データ格納の基本単位**です。

- `表`には`列`と`行`があり、各`列`に対して**データ型**を指定する必要がある。`列`に対して**整合性制約**を設定することで、`列`の入力値を制限することができる。

- 主なOracleデータベースの組込みデータ型

|データ型 |固定長／可変長 |説明 |
|---- |---- |---- |
|CHAR(n) |固定長文字型 |長さがnバイトの固定長の文字データ。<br>**最大サイズは2000バイト、最小サイズは１バイト** |
|VARCHAR2(n) |可変長文字型 |最大長がnバイトまたはn文字の可変長文字データ<br>**最大サイズは4000バイト、最小サイズは１バイトまたは１文字** |
|DATE |固定長日付型 |**日付と時刻**の情報が格納されるデータ型。 |
|NUMBER(p,s) |可変長数字型 |精度がp、位取りがsの数値データ型。<br>**最大38桁の数値を格納可能です。** |

- `制約`は、`表`内の`列`に格納する**値を制限するルールです**。

- `整合性制約`とは、**列に格納されるデータを制限するルール**です。

|制限 |SQL上での表記 |説明 |
|---- |---- |---- |
|NOT NULL |NOT NULL |値がNULLになることを禁止する |
|一意キー |UNIQUE |複数の行で、同じ列または列の組合せで同じ値を持つことを禁止する。<br>値がNULLになることは許可される。複数設定できる。 |
|主キー |PRIMARY KEY |NOT NULL と一意キーが組み合わされるのと同じ動作になる。<br>最大１つ設定できる。 |
|外部キー |FOREIGN KEY |複数の表を関連付けるための共通する列。**参照整合性制約**とも呼びばれる。 |
|チェック |CHECK |データベースの値が指定された条件を満たすようにする。 |

- SQL文を使用した表の作成

```SQL
// 表の作成
CREATE TABLE [スキーマ名.]表名
(
    列名    データ型
    [,列名  データ型...]
);
```

```SQL
// 既存の表の複製
CREATE TABLE 表名 [(列名[,　列名...])]
AS SELECT文;
```

**表の変更　★★**

- `表`に対して、次のような変更作業を実行できます。

  + `表`に新しい`列`を追加する

  + 既存の`列`の`データ型`を変更する

  + 既存の`列`に`デフォルト値`を設定する

  + 既存の`列`を削除する

  + 既存の`列`の名前を変更する

  + `表`を読取り／書込みモードにする

  + `表`を読取り専用モードにする

- SQL文を使用した表の変更

```SQL
-- 列の追加
ALTER TABLE 表名
ADD (
    列名    データ型    [DEFAULT 式] [列ラベル制約]
    [, 列名 データ型    [DEFAULT 式] [列ラベル制約]...]
);
```

```SQL
-- 列ラベル制約の基本構文
列名    [CONSTRAINT    制約名]    制約
```

```SQL
-- 表ラベル制約の基本構文
[CONSTRAINT 制約名]    制約    (列名  [, 列名...])
```

```SQL
-- 既存の列のデータ型を変更
ALTER TABLE 表名
MODIFY (
    列名    データ型    [DEFAULT 式]
    [, 列名 データ型    [DEFAULT 式]...]
);
```

```SQL
-- 制約の追加
ALTER TABLE 表名 ADD 表ラベル制約構文;
```

- 制約は列ラベルまたは表ラベルで定義できる。

**表の削除　★★★★**

- `表`を削除すると、`表`内の**データ**、`表`に定義される**制約**や**索引**、**表の定義情報**も削除される。参照する`ビュー`や`シノニム`を**無効**になる。

- `表`を削除できるのは、**表の所有者**または**DROP ANY TABLE権限**を持つユーザーのみです。

- 削除した`表`はデフォルトでは`ごみ箱`に入ります。リカバリできます。

- `表`の削除により実行される処理は次の通りです。

  + `表`の定義が`データディクショナリ`から削除される。

  + `表`のすべての行が削除される。

  + `表`に定義されているすべての`索引`が削除される。

  + `表`を削除すると既定で`ごみ箱`に入る。

- SQL文を使用した表の削除

``` SQL
DROP TABLE 表名 [PURGE]
```

- SQL文を使用して、`表`を`ごみ箱`に入れないで完全に削除するには**PURGE句**を指定する。

## 8.2 スキーマオブジェクトの追加作成

**索引　★★★**

- `索引`は、検索時のディスクI/Oを減らし、`表`データの検索を高速にするために作成するオブジェクトです。

- データベースの`索引`には「**キーワード**」と「**格納されている表のデータブロックのアドレス**」が記載される。

- `索引`には次の特徴がある

  + `索引`は、`索引セグメント`として`記憶域`を使用するオブジェクトである。

  + `索引`を作成する際は`表領域`を指定できる。

  + `索引`は、`表`に関連付けられる。

  + `索引`は、`表`内の１つ以上の`列`に対して作成できる。

  + `表`に`主キー制約`または`一意キー制約`をしていすると、その`列`には`索引`が暗黙的に作成される。

  + `索引`は、`表`のデータが`DML文`によって挿入、更新、削除されると、そのに伴って**自動的にメンテナンス**される。

- `索引`の種類

|索引の種類 |特徴 |有効な場合 |
|---- |---- |---- |
|Bツリー索引 |`索引`の種類を設定しなかった場合にデフォルトで設定される`索引` |`主キー列`など、`対象列`の値の種類が多い場合 |
|ビットマップ索引 |対象となる`列`の値ごとにビットマップというデータを作成し、`行`ごとの判定(0か1のビット値)を格納する。 |性別`列`や0か1で表す`フラグ列`、固定の種別を格納する`列`など、`対象列`の値の種類が少ない場合 |
|逆キー索引 |対象となる`列`の値をビット単位で反転させて`Bツリー索引`の`索引`データ構造を形成する。 |`対象列`の値の種類が多い、かつ`対象列`の値が昇順で増加する場合 |
|ファンクション索引 |対象となる`列`の値に対して関数や式の値が事前に計算され、その結果が`索引`が`索引対象値`として格納される。 |関数などの計算結果を条件として検索する場合 |

- SQL文を使用した`索引`の作成

```SQL
CREATE [UNIQUE] INDEX 索引名 ON 表名 (列名);
```

- SQL文を使用した`索引`の削除

```SQL
DROP INDEX 索引名;
```

**ビュー　★★★★**

- `ビュー`は、１つまたは複数の`表`や`ビュー`をもとにして作成する「**仮想の表**」です。実態は**SQLのSELECT文**です。**データは格納できない**。

- `ビュー`を使用すると、次のようなメリットがある。

  + SQL文の複雑さをユーザーから隠すことができる。

  + `実表`の特定の`列`や`行`の集合のみにアクセスを限定すると子で、`表`のセキュリティラベルを強化できる。

**ストアドプログラムの管理　★★**

- データベースには、**プログラムを格納できます**。「**ストアドプログラム**」または「**データベース長駐型プログラムユニット**」と呼びます。

- `ストアドプログラム`とは、`PL/SQL`または`Java`記述されたプログラムであり、Oracleデータベース内に作成する`スキーマオブジェクト`です。

- `PL/SQL`は、SQLに対する**Oracleの手続き型言語拡張**です。

- 作成でくるプログラムコードのタイプ

|タイプ |説明 |
|---- |---- |
|パッケージ仕様部 |型、変数、定数、例外、カーソルおよびパッケージの外から参照できるサブプログラムを宣言する。 |
|パッケージ本体 |パッケージ本体部。 |
|プロシージャ |単一のタスクを実行するプログラム |
|ファンクション |単一のタスクを実行するプログラム。<br>呼出し元のプログラムに値を戻す必要がある。 |
|データベーストリガー |表、ビュー、イベントに関連付けられたプログラム。 |

## 8.3 表へのデータのロード

**SQL*Loaderによるデータのロード　★★★**

- データをロードする際は、`SQL*Loader`の**データファイル**と**制御ファイル**を使用します。

- `データファイル`は、「csv」または「xls」ファイルなどであらかじめ作成しております。

- `制御ファイル`(.ctl)は、データを読み込む方法やデータの場所、データの挿入先の表名が記述されたファイルです。

- `SQL*Loader`の特徴

  + `sqlldr コマンド`で起動するコマンドライン・インタフェースである。

  + 外部ファイルからデータベースへデータをバルクロード(大量データの一括ロード)を指定する。

  + 区切り文字、固定レコード、可変レコードおよびストリームなど、多数の入力形式をサポートしている。

  + 同時に複数の`表`をロードできる。

  + 強力なデータのフィルター機能がある。

**データのロード方法　★★★**

- `SQL*Loader`は、状況に応じて、`従来型パス`、`ダイレクトパス`および`外部表`の３つの異なるデータのロード方法を使用します。

|ロード方法 |説明 |
|---- |---- |
|従来型パス |デフォルトのロード方法。<br>SQL文**INSTER文**が生成されて、データが表に挿入される。 |
|ダイレクトパス |**ダイレクトパスAPI**を使用して、データをサーバーのロードエンジンに渡す。<br>ロードエンジンは、渡されたデータから列配列構造体を作成する。 |

- `SQL Developer`から`SQL*Loader`を呼び出して、`表`に大量のデータを高速にロードすることができる。

- `SQL*Loader`のロード方法は、INSTER文を作成して実行する`従来型パス`と、他のユーザーとデータベースリソースの競合が発生せず、オーバーヘッドを大幅に削減できるダイレクトパスがある。

- `SQL*Loader`のデータファイルと制御ファイルを準備しておく。

- `SQL*Loader`の制御ファイルは、自動生成させることもできる。

## リンク

- [ディレクトリ](./../directory.md)

- 前章：[第七章 ユーザーおよびセキュリティの管理](Chapter07.md)

- 次章：[第九章 バックアップおよびリカバリの実行](Chapter09.md)
